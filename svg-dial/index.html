<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>svg in nested grid</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <style>
        body {
            padding: 0;
            margin: 40px 20px;
        }
        .dial {
            height: 50vh;   /* 20% of viewport height */
            /*height: 120px;*/
            background-color: #ccc;
            display: block;
        }
        .dial text {
            font-family: sans-serif;
            font-size: 100%;
            cursor: default;
            z-index: 1;
        }
        text.value, text.label {
            text-anchor: middle;
        }
        .arc {
            stroke: black;
            stroke-width: 4px;
            fill: transparent;
        }
        .back {
            stroke: #aaa;
            stroke-width: 4px;
            fill: transparent;
        }
    </style>
</head>
<body>
<!--
    <svg class="dial" viewBox="0 0 100 120">
        <text x="50" y="55" class="value">67.89</text>
        <text x="50" y="110" class="label">Foo Bar</text>
        <path class="arc" d="M 10,50 A 40,40 0 1,1 50,90 L 50,70"></path>
    </svg>
-->
    <div>
        <svg class="dial"></svg>
    </div>
<!--
    <div>
        &lt;!&ndash;abs x, y: <span id="mousexy"></span><br />&ndash;&gt;
        dx, dy: <span id="offsetxy"></span><br />
        angle: <span id="angle"></span><br />
        distance: <span id="distance"></span><br />
    </div>
-->
</body>
<script>

    // All computations are done in standard cartesian or polar coordinates.
    // The convertion to the dial coordinates are done at the very end.
    // /!\ All angles are in degrees unless noted.

/*
    function infos(dx, dy, angle, angleDegree, distance) {
//        $('#mousexy').text(`${x}, ${y}`);
        $('#offsetxy').text(`${dx.toFixed(2)}, ${dy.toFixed(2)}`);
        $('#angle').text(`${angleDegree.toFixed(2)}`);
        $('#distance').text(`${distance.toFixed(2)}`);
    }
*/

    // NOTE: viewBox must be 100x120: 100x100 for the arc and 100x20 below for the label.

    const HALF_WIDTH = 50;      // viewBox/2
    const HALF_HEIGHT = 50;     // viewBox/2
    const RADIUS = 40;          // a bit less than viewBox/2 to have a margin outside the arc. Must also takes into account the width of the arc stroke.

    // mouse drag support
    var currentTarget;
    var targetRect;
//    var knobCenter;
//    var offx, offy;

    // Center of arc in dial coordinates and in ViewPort's pixels relative to the <svg> ClientBoundingRect.
    var arcCenterXPixels = 0;
    var arcCenterYPixels = 0; // equal to arcCenterXPixels because the dial is a circle

    // start of arc, in ViewBox coordinates, computed once during the init
    var arcStartX;     // dial coordinates
    var arcStartY;     // dial coordinates

    const ZERO_AT = 270.0;  // the 0 degree will be at 270 polar degrees (6 o'clock).

    var arcStart = 30.0;        // Angle in dial coordinates (0 at 6 0'clock)
    var arcEnd = 330.0;         // Angle in dial coordinates (0 at 6 0'clock)
    var arcStartPolar = 0.0;    // initialized in init()
    var arcEndPolar = 0.0;      // initialized in init()
    var polarAngle = 0.0;       // Angle in polar coordinates (0 at 3 o'clock)
    var distance = 0.0;         // distance, in polar coordinates, from center of arc to last mouse position


    /**
     * Angle in degrees in polar coordinates (0 degrees at 3 o'clock)
     */
    function setPolarAngle(angle) {

//        console.log(`setPolarAngle ${angle} limits: ${polarToDialAngle(arcStartPolar)} ${polarToDialAngle(arcEndPolar)}`);
        let a = (angle + 360.0) % 360.0;    // we add 360 to handle negative values down to -360
        console.log(`setPolarAngle ${a}`);
        // apply boundaries
        let b = polarToDialAngle(a);
//        console.log(`setPolarAngle ${b}`);
        if ((b < arcStart) || (b > arcEnd)) {
            console.log(`ignore ${b}`);
            return;
        }

        polarAngle = a;
    }

    function incPolarAngle(increment) {
        console.log(`incPolarAngle ${increment}`);
        setPolarAngle(polarAngle + increment);
    }

    /**
     * Angle in degrees in polar coordinates (0 degrees at 3 o'clock)
     */
    function getPolarAngle() {
        return polarAngle;
    }

    /**
     * Return polar coordinates angle from our "dial coordinates" angle
     */
    function dialToPolarAngle(angle) {
        let a = ZERO_AT - angle;
        if (a < 0) a = a + 360.0;
        console.log(`dialToPolarAngle ${angle} -> ${a}`);
        return a;
    }

    function polarToDialAngle(angle) {
        //TODO: CCW or CW. "-" for changing CCW to CW
        return (ZERO_AT - angle + 360.0) % 360.0;
    }

    /**
     * Return dial coordinates angle from the current polar coordinates angle
     */
    function getDialAngle() {
        return polarToDialAngle(getPolarAngle());
    }

    /**
     * x is 0..1
     */
    function getArcX(x) {
        return HALF_WIDTH + (RADIUS * x);
//        return (RADIUS * x);
    }

    /**
     * y is 0..1
     */
    function getArcY(y) {
        // (2 * HALF_HEIGHT) - (HALF_HEIGHT + (RADIUS * y));
        return HALF_HEIGHT - (RADIUS * y);
//        return (RADIUS * y);
    }

    /**
     * Rotation of 270ยบ: (x,y) becomes (y,-x)
     */
/*
    function getDialCoordinates(x, y) {
        // TODO: make rotation configurable
        console.log(`getDialCoordinates ${x} ${y} --> ${y} ${-x} `);
        return [y, -x];
    }
*/

    /**
     * startAngle in dial coordinates
     */
    function init(startAngle) {

        console.log('INIT');

        arcStartPolar = dialToPolarAngle(arcStart);
        arcEndPolar = dialToPolarAngle(arcEnd);

        setPolarAngle(dialToPolarAngle(startAngle));   // init polarAngle

        console.log(`init start ${arcStartPolar} end ${arcEndPolar}`);

        let angle_rad = getPolarAngle() * Math.PI / 180.0;

        arcStartX = getArcX(Math.cos(angle_rad));   // viewBox coordinates (independant from borwser resizing)
        arcStartY = getArcY(Math.sin(angle_rad));   // viewBox coordinates (independant from borwser resizing)

        console.log(`init: ${arcStartX}, ${arcStartY}, ${getPolarAngle()}`);
    }

    /**
     * angle is in degrees (polar, 0 at 3 o'clock)
     */
    function getPath(endAnglePolar) {

        console.log('GETPATH');

        console.log(`getPath ${endAnglePolar}`);

        let a_rad = endAnglePolar * Math.PI / 180.0;
        let endX = getArcX(Math.cos(a_rad));
        let endY = getArcY(Math.sin(a_rad));

        let deltaAngle = (arcStartPolar - endAnglePolar + 360.0) % 360.0;
        let largeArc = deltaAngle < 180.0 ? 0 : 1;

        let p = `M ${arcStartX},${arcStartY} A ${RADIUS},${RADIUS} 0 ${largeArc},1 ${endX},${endY}`;

        console.log(p);

        return p;
    }

    function updateDial() {
        //TODO: setLabel()
        //TODO: setValue()
        currentTarget.childNodes[1].textContent = getDialAngle().toFixed(0);
        currentTarget.childNodes[3].setAttributeNS(null, "d", getPath(getPolarAngle()));
    }

    /**
     * startDrag() must have been called before to init the targetRect variable.
     */
    function mouseUpdate(e) {

//        console.log(`mouse d = ${e.offsetX}, ${e.offsetY}`);

        // (e.offsetX, e.offsetY) == (0, 0) at top-left corner of <svg> viewBox.

        // mouse delta in cartesian coordinate with path center=0,0 and scaled (-1..0..1) relative to path:
        // <svg> center:       (dx, dy) == ( 0,  0)
        // <svg> top-left:     (dx, dy) == (-1,  1)
        // <svg> bottom-right: (dx, dy) == ( 1, -1) (bottom right of the 100x100 viewBox, ignoring the bottom 100x20 for the label)
        let dx = (e.offsetX - arcCenterXPixels) / (targetRect.width / 2);
        let dy = - (e.offsetY - arcCenterYPixels) / (targetRect.width / 2);  // targetRect.width car on a 20px de plus en hauteur pour le label

//        console.log(`mouse cartesian coord = ${dx}, ${dy}`);

        // convert to polar coordinates
        let angle_rad = Math.atan2(dy, dx);

        if (angle_rad < 0) angle_rad = 2.0*Math.PI + angle_rad;

        console.log(`mouseUpdate: angle_rad ${angle_rad}`);

        setPolarAngle(angle_rad * 180.0 / Math.PI);     // rads to degs

        // distance from arc center to mouse position
        distance = Math.sqrt(dx*(HALF_WIDTH/RADIUS)*dx*(HALF_WIDTH/RADIUS) + dy*(HALF_HEIGHT/RADIUS)*dy*(HALF_HEIGHT/RADIUS));

    }

    function startDrag(e) {

        e.preventDefault();

        // API: Event.currentTarget
        //      Identifies the current target for the event, as the event traverses the DOM. It always REFERS TO THE ELEMENT
        //      TO WHICH THE EVENT HANDLER HAS BEEN ATTACHED, as opposed to event.target which identifies the element on
        //      which the event occurred.
        //      https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget

        currentTarget = e.currentTarget;

        // get the boundingRect of the <svg> object. The coordinates are in viewport's pixels.
        targetRect = currentTarget.getBoundingClientRect(); // currentTarget must be the <svg...> object
//        console.log('startDrag targetRect', targetRect);

        // API: Element.getBoundingClientRect()
        //      The Element.getBoundingClientRect() method returns the size of an element and its position RELATIVE TO THE VIEWPORT.
        //      https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect

        // Note: we must take the boundingClientRect of the <svg> and not the <path> because the <path> bounding rect
        //       is not constant because it encloses the current arc.

        // by design, the arc center is at equal distance from top and left.
        arcCenterXPixels = targetRect.width / 2;
        //noinspection JSSuspiciousNameCombination
        arcCenterYPixels = arcCenterXPixels;

//        console.log(`startDrag arc center = ${arcCenterXPixels}, ${arcCenterYPixels}`);

        document.addEventListener('mousemove', this.handleDrag, false);
        document.addEventListener('mouseup', this.endDrag, false);

        mouseUpdate(e);

        updateDial();
    }

    /**
     *
     * @param e
     */
    function handleDrag(e) {
        e.preventDefault();

//        console.log("handleDrag");

        mouseUpdate(e);

        updateDial();
    }

    function endDrag() {
        console.log("endDrag");
        document.removeEventListener('mousemove', handleDrag, false);
        document.removeEventListener('mouseup', endDrag, false);
        // this.setState(emptyKnobState());
    }



    var minDeltaY;

    function mouseWheelHandler(e) {

        // https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers
        // https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js

        // cross-browser wheel delta
        var e = window.event || e; // old IE support

        e.preventDefault();

        if (e.deltaY != 0) {
            // normalize Y delta
            if (minDeltaY > Math.abs(e.deltaY) || !minDeltaY) {
                minDeltaY = Math.abs(e.deltaY);
            }
        }

        console.log('mouse wheel', e.wheelDelta, e.wheelDeltaX, e.wheelDeltaY, e.detail);

        // important!
        currentTarget = e.currentTarget;

        incPolarAngle(-(e.deltaY / minDeltaY));     // TODO: make mousewheel direction configurable

//        let p = getPath(currentAngle * Math.PI / 180.0);
//        let p = getPath(getPolarAngle());

        // TODO: timing --> speed
        // https://stackoverflow.com/questions/22593286/detect-measure-scroll-speed

//        currentTarget.childNodes[0].textContent = getDialAngle().toFixed(0);
//        currentTarget.childNodes[2].setAttributeNS(null, "d", p);
        updateDial();

        return false;
    }




    // https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course
    //
    // The first argument for all the DOM2 namespace aware methods must be the namespace name (also known as the namespace URI)
    // of the element or attribute in question. For SVG elements this is 'http://www.w3.org/2000/svg'.
    // However, note carefully: the Namespaces in XML 1.1 recommendation states that the namespace name for attributes
    // without a prefix does not have a value. In other words, ALTHOUGH THE ATTRIBUTES BELONG TO THE NAMESPACE OF THE TAG,
    // YOU DO NOT USE THE TAG'S NAMESPACE NAME. INSTEAD, YOU MUST USE NULL AS THE NAMESPACE NAME FOR UNQUALIFIED (PREFIXLESS) ATTRIBUTES.
    // So, to create an SVG rect element using document.createElementNS(), you must write:

    const NS = "http://www.w3.org/2000/svg";

    function createDial(svg, dialAngle, label) {


        let back = document.createElementNS(NS, "circle");
        back.setAttributeNS(null, "cx", "50");
        back.setAttributeNS(null, "cy", "50");
        back.setAttributeNS(null, "r", "40");
        back.setAttribute("class", "back");
        svg.append(back);

        let valueText = document.createElementNS(NS, "text");
        valueText.setAttributeNS(null, "x", "50");
        valueText.setAttributeNS(null, "y", "55");
        valueText.setAttribute("class", "value");
        valueText.textContent = dialAngle;
        svg.appendChild(valueText);

        let labelText = document.createElementNS(NS, "text");
        labelText.setAttributeNS(null, "x", "50");
        labelText.setAttributeNS(null, "y", "110");
        labelText.setAttribute("class", "label");
        labelText.textContent = label;
        svg.appendChild(labelText);

        // https://www.w3.org/TR/SVG/render.html#RenderingOrder:
        // Elements in an SVG document fragment have an implicit drawing order, with the first elements in the SVG document
        // fragment getting "painted" first. Subsequent elements are painted on top of previously painted elements.
        // ==> first element -> "painted" first


        init(arcStart);
        setPolarAngle(dialToPolarAngle(dialAngle));     // TODO: remove setPolarAngle()
        let p = getPath(dialToPolarAngle(dialAngle));     // TODO: value to arc

        let path = document.createElementNS(NS, "path");
        //path.setAttributeNS(null, "d", "M 10,50 A 40,40 0 1,1 50,90 L 50,70");
        path.setAttributeNS(null, "d", p);
        path.setAttribute("class", "arc");


        svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
        svg.setAttributeNS(null, "viewBox", "0 0 100 120");
        svg.setAttribute("class", "dial");
        svg.appendChild(path);


        let xAxis = document.createElementNS(NS, "line");
        xAxis.setAttributeNS(null, "x1", "0");
        xAxis.setAttributeNS(null, "y1", "50");
        xAxis.setAttributeNS(null, "x2", "100");
        xAxis.setAttributeNS(null, "y2", "50");
        xAxis.setAttributeNS(null, "stroke", "blue");
        svg.append(xAxis);

        let yAxis = document.createElementNS(NS, "line");
        yAxis.setAttributeNS(null, "x1", "50");
        yAxis.setAttributeNS(null, "y1", "0");
        yAxis.setAttributeNS(null, "x2", "50");
        yAxis.setAttributeNS(null, "y2", "100");
        yAxis.setAttributeNS(null, "stroke", "blue");
        svg.append(yAxis);




        //polarAngle = -90;

        $(svg).on("mousedown", function(e) {
            startDrag(e);
        });
        $(svg).on("mousewheel", function(e) {
            mouseWheelHandler(e);
        });

        return svg;
    }

    $(function () {
        var dials = document.querySelectorAll('svg.dial');
        [].forEach.call(dials, function(item) {
            createDial(item, 300.0, "Foo bar");
        });
    });

</script>
</html>
